{"meta":{"title":"FLWLW","subtitle":null,"description":null,"author":"FLWLW","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-07-23T23:57:10.000Z","updated":"2018-07-23T23:57:10.754Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2018-07-24T01:22:21.000Z","updated":"2018-07-24T01:22:21.631Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-23T23:57:39.000Z","updated":"2018-07-23T23:57:39.681Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-23T23:57:01.000Z","updated":"2018-07-23T23:57:01.799Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-23T23:57:24.000Z","updated":"2018-07-23T23:57:24.155Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"洛谷P1908 逆序对","slug":"洛谷P1908-逆序对","date":"2018-07-24T08:43:32.668Z","updated":"2018-07-24T08:49:15.401Z","comments":true,"path":"2018/07/24/洛谷P1908-逆序对/","link":"","permalink":"http://yoursite.com/2018/07/24/洛谷P1908-逆序对/","excerpt":"","text":"这道题我使用的是归并排序， 而且只在归并排序上加一句话即可 题目：逆序对 先来回忆一下归并排序的原理： 有数列：2 7 5 4 9 8 6 利用归并排序： 先二分： 2 7 5 4 9 8 6 再分开排序： 2 4 5 7 6 8 9 取第一个数列第一个数与第二个数列第一个数进行比较，取较小的一个数加入一个临时数组，而后删除这个数： 4 5 7 6 8 9 重复以上步骤得： ​ 8 9 会发现此时第二个数组还有两数，而第一个数列已被弹空，此时就直接将第二个数列的所有剩下的加入临时数组，最后再将临时数组里的数一一赋值给原数组 回到“取第一个数列第一个数与第二个数列第一个数进行比较，取较小的一个数加入一个临时数组，而后删除这个数”这一步： ​ 4 5 6 6 8 9 2 想想逆序对定义： 逆序对就是序列中ai &gt; aj且i &lt; j的有序对 那么如果2比在6前且2比6小，所以2便能与6组成一对逆序对，而由于第二个数列已经排序好， 所以6后的数一定大于6， 于是后面的数8 9也一定能与2组成逆序对 其他同理（自己试试其他数） 所以当归并排序完后， 逆序对也求出来了 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define ll long long//将 long long 用 ll 替换 using namespace std;ll a[1000001], b[1000001], n, ans;// a为原数组，b为临时数组 void mergesort(ll l, ll r) &#123; if(l &gt;= r) return ;//停止条件 ll m = l + (r - l) / 2;//二分，m = l + (r - l) / 2 和 m = (l + r) / 2 是一样的，这里为防止溢出 mergesort(l, m);//递归左边 mergesort(m + 1, r);//递归右边 ll l1 = l;//第一个数列指针 ll l2 = m + 1;//第二个数列指针 ll lb = l;//临时数组指针 while(l1 &lt;= m || l2 &lt;= r) &#123; if(l1 &gt; m) &#123;b[lb ++] = a[l2]; l2 ++;&#125;//第一个数列走完时 else if(l2 &gt; r) &#123;b[lb ++] = a[l1]; l1 ++;&#125;//第二个数列走完时 else &#123;//第一个数列和第二个数列都有数时 if(a[l1] &lt; a[l2]) &#123;b[lb ++] = a[l1]; l1 ++;&#125;//第一个数列第一个数小于第二个数列第一个数时 else &#123;b[lb ++] = a[l2]; l2 ++; ans += m - l1 + 1;/*此处为加上的一句求逆序对个数*/&#125;//第一个数列第一个数大于第二个数列第一个数时 &#125; &#125; for(int i = l; i &lt;= r; i ++) &#123; a[i] = b[i];//赋值回去 &#125;&#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; &#125; mergesort(1, n); cout &lt;&lt; ans ; return 0;&#125;","categories":[],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-07-24T06:56:43.684Z","updated":"2018-07-24T06:56:43.719Z","comments":true,"path":"2018/07/24/归并排序/","link":"","permalink":"http://yoursite.com/2018/07/24/归并排序/","excerpt":"","text":"归并排序是一种十分优秀的排序算法，而且通过归并排序还可以用来求逆序对，这个我们后面再说。 归并的原理和注意点就一个例子就可以解释了： 有数列：2 7 5 4 9 8 6 利用归并排序： 先二分： 2 7 5 4 9 8 6 再分开排序： 2 4 5 7 6 8 9 取第一个数列第一个数与第二个数列第一个数进行比较，取较小的一个数加入一个临时数组，而后删除这个数： 4 5 7 6 8 9 重复以上步骤得： ​ 8 9 会发现此时第二个数组还有两数，而第一个数列已被弹空，此时就直接将第二个数列的所有剩下的加入临时数组，最后再将临时数组里的数一一赋值给原数组。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define ll long long//将 long long 用 ll 替换 using namespace std;ll a[1000001], b[1000001], n;// a为原数组，b为临时数组 void mergesort(ll l, ll r) &#123; if(l &gt;= r) return ;//停止条件 ll m = l + (r - l) / 2;//二分，m = l + (r - l) / 2 和 m = (l + r) / 2 是一样的，这里为防止溢出 mergesort(l, m);//递归左边 mergesort(m + 1, r);//递归右边 ll l1 = l;//第一个数列指针 ll l2 = m + 1;//第二个数列指针 ll lb = l;//临时数组指针 while(l1 &lt;= m || l2 &lt;= r) &#123; if(l1 &gt; m) &#123;b[lb ++] = a[l2]; l2 ++;&#125;//第一个数列走完时 else if(l2 &gt; r) &#123;b[lb ++] = a[l1]; l1 ++;&#125;//第二个数列走完时 else &#123;//第一个数列和第二个数列都有数时 if(a[l1] &lt; a[l2]) &#123;b[lb ++] = a[l1]; l1 ++;&#125;//第一个数列第一个数小于第二个数列第一个数时 else &#123;b[lb ++] = a[l2]; l2 ++;&#125;//第一个数列第一个数大于第二个数列第一个数时 &#125; &#125; for(int i = l; i &lt;= r; i ++) &#123; a[i] = b[i];//赋值回去 &#125;&#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; &#125; mergesort(1, n); for(int i = 1; i &lt;= n; i ++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; return 0;&#125;","categories":[],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"分治初解","slug":"分治","date":"2018-07-24T03:03:09.369Z","updated":"2018-07-24T03:12:40.559Z","comments":true,"path":"2018/07/24/分治/","link":"","permalink":"http://yoursite.com/2018/07/24/分治/","excerpt":"","text":"分治是一种基于二分的解题思路分治字面理解即为分开治理以题目最大子段和为例子(题目：最大子段和)(PS：请先看题)题目样例：72 -4 3 -1 2 -4 3用分治思想来看我们需要先把这个数列二分一下得到：2 -4 3 -1 和 2 -4 3接着分别从两个新数列的开头向后走第一个数列从-1开始向左走，每次更新最大值（左边情况）第二个数列从2开始向右走（右边情况）将第一个数列和第二个数列的最大值加起来得到中间向两边找的情况，且必定为最优的可能答案（想想为什么） 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define ll long long//把long long 用 ll 代替 using namespace std;const int INF = 0x7fffffff;//设定最大值，应为有负数 ll a[1000001], ans = -INF, n;void zdh(ll l, ll r) &#123; if(l &gt;= r) return; ll m = l + (r -l) / 2;//二分 zdh(l, m);//递归左边 zdh(m + 1, r);//递归右边 ll a1 = 0, a2 = 0, ans1 = -INF, ans2 = -INF;//a1, a2求和， ans1, ans2更新答案 for(int i = m; i &gt;= l; i --) &#123;//向左找 a1 += a[i];//加起来 ans1 = max(a1, ans1);//更新 ans = max(ans, ans1);//更新最后答案 &#125; for(int j = m + 1; j &lt;= r; j ++) &#123;//向右找 a2 += a[j]; ans2 = max(a2, ans2); ans = max(ans, ans2); &#125; ans = max(ans1 + ans2, ans);//更新中间情况 &#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; &#125; zdh(1, n); cout &lt;&lt; ans ; return 0;&#125;","categories":[],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/分治/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-21T07:16:05.774Z","updated":"2018-07-24T00:55:39.729Z","comments":true,"path":"2018/07/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}